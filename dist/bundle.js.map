{"version":3,"sources":["webpack://Perceptor/webpack/universalModuleDefinition","webpack://Perceptor/webpack/bootstrap","webpack://Perceptor/./src/config/defaultConfig.js","webpack://Perceptor/./src/config/helper.js","webpack://Perceptor/./src/utils/view.js","webpack://Perceptor/./src/spectators/viewportSpectator.js","webpack://Perceptor/./src/spectators/timeSpectator.js","webpack://Perceptor/./src/spectators/elementSpectator.js","webpack://Perceptor/./src/spectators/durationSpectator.js","webpack://Perceptor/./src/spectators/defaultSpectators.js","webpack://Perceptor/./src/subscribers/domSubscriber.js","webpack://Perceptor/./src/subscribers/consoleSubscriber.js","webpack://Perceptor/./src/subscribers/defaultSubscriber.js","webpack://Perceptor/./src/spectators/spectatorManager.js","webpack://Perceptor/./src/subscribers/subscriberManager.js","webpack://Perceptor/./src/schedulers/visibilityHelper.js","webpack://Perceptor/./src/schedulers/Scheduler.js","webpack://Perceptor/./src/schedulers/intervalScheduler.js","webpack://Perceptor/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","defaultConfig","threshold","scheduler","interval","attentionMode","viewOffset","top","left","right","bottom","subscribers","spectators","clickHandler","defaultSubscriber","arrayMergeList","objectMergeList","isArray","candidate","Array","getCurrentViewport","document","documentElement","clientHeight","assign","getCurrentScrollPosition","height","width","clientWidth","pageXOffset","pageYOffset","getCurrentViewportElementPosition","node","position","getBoundingClientRect","getElementPosition","scrollPos","viewPortSpectator","context","element","view","isBoxed","config","container","undefined","nodeRight","nodeBottom","containerLeft","containerTop","containerRight","containerBottom","leftCoordinates","rightCoordinates","topCoordinates","bottomCoordinates","subView","lc","rc","tc","bc","hasIntersectingArea","surface","isVisible","timeSpectator","time","Date","getTime","elementSpectator","pContext","id","tagName","durationSpectator","currentResult","prevResult","duration","defaultSpectators","mainContainer","createElement","body","appendChild","style","backgroundColor","opacity","currentElementContainers","createOrUpdateElementContainer","innerHTML","JSON","stringify","getHTMLPaintForObject","domSubscriber","perceptorInstance","consoleSubscriber","console","log","subscriberName","SpectatorManager","[object Object]","chain","this","fn","push","length","perceptorContext","updatedResult","reduce","spectator","SubscriberManager","PerceptorContext","data","every","subscribe","visibilityHelper_hidden","visibilityChange","hidden","msHidden","webkitHidden","onPageVisibilityChange","lastVisibility","addEventListener","currentVisibility","isPageVisible","Scheduler","Error","intervalScheduler_IntervalScheduler","options","super","spectatorChain","subscriberChain","_enabled","_schedule","handleId","clearInterval","setInterval","spectatorsResult","run","dispatch","src_Perceptor","DOMElement","Element","baseConfig","extensionConfig","includes","mergeConfig","defaults","event","clearSchedule","removeEventListener","__webpack_exports__"],"mappings":"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","file":"bundle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Perceptor\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Perceptor\"] = factory();\n\telse\n\t\troot[\"Perceptor\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","const config = {\n\t//\n\t//This denotes the threshold (Percentage) of surface area that an Element is considered to be visible\n\t// e.g, a. if threshold is 100, & if 100% of the Element is visible, it will be considered as visible\n\t// \t\tb. if threshold is 20, & %age element visibility >20 , it will be considered as visible\n\t// defaults to 100\n\tthreshold: 100,\n\n\t// scheduler config\n\tscheduler: {\n\t\tmode: 'interval', // interval, scroll, raf, observer\n\t\t// currently on interval is supported\n\t\tinterval: 500, // ms of interval time, applicable for only \"interval\" type of mode\n\t\tattentionMode: true // Mode to disable schedulers if browser if not in focus (although visible on the screen)\n\t},\n\n\t// By default, visibility of element is based on viewport of the browser.\n\t// This configuration helps in making the viewport for detection shorter from the edges.\n\t// In case of site with fixed header, or sidebar, or sticky footer, these setting can be used to accurately calculate\n\t// visibility of the element\n\tviewOffset: {\n\t\ttop: 0, //px\n\t\tleft: 0, //px\n\t\tright: 0, //px\n\t\tbottom: 0 //px\n\t},\n\n\t// list of additional subscribers who would be part of subscriberChain\n\tsubscribers: [],\n\n\t// list of additional spectators who would be part of spectatorChain to calculate the visibililty.\n\tspectators: [],\n\n\t// function that would be triggered with the context of current perceptor instance on 'click' event\n\tclickHandler: () => {},\n\n\t// The default subscriber that has to be used. If you add a subscriber in subscribers option, you can disable the default subscriber by defaultSubscriber: 'none'\n\tdefaultSubscriber: 'dom' // either `dom`, `console`, `none`\n};\n\nexport default config;\n","const arrayMergeList = ['subscribers', 'spectators'];\nconst objectMergeList = ['scheduler', 'viewOffset'];\n\nconst isArray = candidate => {\n\treturn Array.isArray(candidate);\n};\n\n/**\n * Merges Perceptible config\n * @param {object} baseConfig - source configuration\n * @param {object} extensionConfig - extension configuration\n * @returns {object} merged configuration\n */\nexport function mergeConfig(baseConfig, extensionConfig) {\n\tif (extensionConfig) {\n\t\tfor (var key in extensionConfig) {\n\t\t\t// If key is candidate which should be joined over instead of over-written\n\t\t\tif (arrayMergeList.includes(key)) {\n\t\t\t\textensionConfig[key] = isArray(extensionConfig[key]) ? extensionConfig[key] : [extensionConfig[key]];\n\t\t\t\tbaseConfig[key] = baseConfig[key] || [];\n\t\t\t\tbaseConfig[key] = isArray(baseConfig[key]) ? baseConfig[key] : [baseConfig[key]];\n\t\t\t\textensionConfig[key] = [...baseConfig[key], ...extensionConfig[key]];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If key is candidate which should be joined over instead of over-written\n\t\t\tif (objectMergeList.includes(key)) {\n\t\t\t\tbaseConfig[key] = baseConfig[key] || {};\n\t\t\t\textensionConfig[key] = Object.assign({}, baseConfig[key], extensionConfig[key]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn Object.assign({}, baseConfig, extensionConfig);\n}\n","/**\n * Provides current Scroll Position and current resolution of the viewport\n * @return {object} - {left, top} : Scroll Position from (0,0) of the view, {height, width} : Resolution of current visible Viewport\n */\nexport const getCurrentViewport = function() {\n\tif (document.documentElement && document.documentElement.clientHeight) {\n\t\treturn Object.assign(getCurrentScrollPosition(), { height: document.documentElement.clientHeight, width: document.documentElement.clientWidth });\n\t}\n\treturn { left: 0, top: 0, width: 0, height: 0 };\n};\n\n/**\n * Provides current Scroll Position\n * @return {object} - {left, top} : Scroll Position from (0,0)\n */\nexport const getCurrentScrollPosition = function() {\n\treturn { left: window.pageXOffset, top: window.pageYOffset };\n};\n\n/**\n * Provides Position of current element and resolution\n * @param {Element} node - HTMLElement\n * @return {object} - {left, top} : Scroll Position from current viewport, height, width} : Resolution\n */\nexport const getElementPosition = function(node) {\n\tlet position = node.getBoundingClientRect();\n\treturn { left: position.left, top: position.top, height: position.height, width: position.width };\n};\n\n/**\n * Provides Position of current element and resolution\n * @param {Element} node - HTMLElement\n * @return {object} - {left, top} : Scroll Position from (0,0), height, width} : Resolution\n */\nexport const getCurrentViewportElementPosition = function(node) {\n\tlet position = getElementPosition(node);\n\tlet scrollPos = getCurrentScrollPosition();\n\treturn { left: position.left + scrollPos.left, top: position.top + scrollPos.top, height: position.height, width: position.width };\n};\n","import { getCurrentViewportElementPosition, getCurrentViewport } from '../utils/view';\n\n/**\n * Adds isVisible property based on subView.surface visibility.\n * subView hold information about current dimensions of Perceptor element that is currently viewable in current viewPort.\n * @param {Perceptor} context\n */\nexport default function viewPortSpectator(context) {\n\tlet element = getCurrentViewportElementPosition(context.element);\n\tlet view = getCurrentViewport(); //including scroll\n\treturn isBoxed(view, element, context.config);\n}\n\n/**\n * Detect if any edge lies in the view\n * @param {boolean} lc - Left Co-ordinate lie in region?\n * @param {boolean} rc - Right Co-ordinate lie in region?\n * @param {boolean} tc - Top Co-ordinate lie in region?\n * @param {boolean} bc - Bottom Co-ordinate lie in region?\n */\nconst hasIntersectingArea = (lc, rc, tc, bc) => {\n\treturn (lc && tc) || (lc && bc) || (rc && tc) || (rc && bc);\n};\n\n/**\n *\n * Calculates if `node` has some intersection area in `container`\n * @param {object} container - viewport to test the node\n * @param {object} node -  candidate to testing if it is inside container\n * @param {object} config - Additional Configuration\n */\nconst isBoxed = function(container, node, config) {\n\tconst threshold = config && config['threshold'] !== undefined ? config.threshold : 100;\n\tconst { viewOffset = { top: 0, left: 0, right: 0, bottom: 0 } } = config;\n\n\tconst nodeRight = node.left + node.width;\n\tconst nodeBottom = node.top + node.height;\n\n\t// do not pollute original object\n\tconst containerLeft = container.left + viewOffset.left;\n\tconst containerTop = container.top + viewOffset.top;\n\tconst containerRight = containerLeft + container.width - viewOffset.right;\n\tconst containerBottom = containerTop + container.height - viewOffset.bottom;\n\n\t// Find if these border l=are inside the box\n\tconst leftCoordinates = node.left >= containerLeft && node.left <= containerRight;\n\tconst rightCoordinates = nodeRight <= containerRight && nodeRight >= containerLeft;\n\tconst topCoordinates = node.top >= containerTop && node.top <= containerBottom;\n\tconst bottomCoordinates = nodeBottom <= containerBottom && nodeBottom > containerTop;\n\n\tconst subView = {};\n\n\tif (hasIntersectingArea(leftCoordinates, rightCoordinates, topCoordinates, bottomCoordinates)) {\n\t\t// subview that is intersecting `container` and `node`\n\t\tsubView.left = leftCoordinates ? node.left : containerLeft;\n\t\tsubView.right = rightCoordinates ? nodeRight : containerRight;\n\t\tsubView.top = topCoordinates ? node.top : containerTop;\n\t\tsubView.bottom = bottomCoordinates ? nodeBottom : containerBottom;\n\t\t// percentage of `node` that is visibile in `container`\n\t\tsubView.surface = ((((subView.right - subView.left) / node.width) * (subView.bottom - subView.top)) / node.height) * 100;\n\t}\n\n\treturn { isVisible: subView.surface >= threshold, subView };\n};\n","/**\n * adds 'time' property in current SpectatorResult.\n * @returns {object} - resultant\n */\nexport default function timeSpectator() {\n\treturn { time: new Date().getTime() };\n}\n","/**\n * Adds current perceptor element property in current SpectatorResult.\n * @param {Perceptor} pContext\n * @returns {object} - resultant\n */\nexport default function elementSpectator(pContext) {\n\tconst { element = {} } = pContext;\n\treturn { element: { id: element.id, tagName: element.tagName } };\n}\n","/**\n * Overall duration for which the Perceptor was visible\n * @param {Perceptor} context\n * @param {object} currentResult\n * @param {object} prevResult\n * @returns {object} - resultant\n */\nexport default function durationSpectator(context, currentResult, prevResult) {\n\t/***\n\t *\n\t * This spectator depends on viewportSpectator and time spectator\n\t * Cases:\n\t * 1. Currently visible and previously not visible -> Just came under the view\n\t * 2. Currently visible and previously visible -> Add the count\n\t * 3. Currently not visible and previously not visible -> nothing to track\n\t * 4. Currently not visible and previously visible -> Got hidden\n\t *\n\t */\n\n\tlet { duration = 0 } = prevResult;\n\n\tif (currentResult.isVisible && prevResult.isVisible) {\n\t\tduration += context.config.scheduler.interval; //currentResult.time - prevResult.time;\n\t}\n\n\treturn { duration };\n}\n","import viewPortSpectator from './viewportSpectator';\nimport timeSpectator from './timeSpectator';\nimport elementSpectator from './elementSpectator';\nimport durationSpectator from './durationSpectator';\n\n/**\n * Returns default Spectator list\n *\n * @returns {list<function>} - Default SPectators to be used to detect the visibility\n */\nconst getDefaultSpectators = () => {\n\treturn [timeSpectator, elementSpectator, viewPortSpectator, durationSpectator];\n};\n\nexport default getDefaultSpectators;\n","// This reporter requires DOM Element which will be Absolute display,\nconst mainContainer = document.createElement('div');\nmainContainer.id = 'dreporter';\ndocument.body.appendChild(mainContainer);\n\nmainContainer.style.backgroundColor = '#e5e5e5';\nmainContainer.style.width = 'auto';\nmainContainer.style.position = 'fixed';\nmainContainer.style.bottom = '0';\nmainContainer.style.left = '0';\nmainContainer.style.opacity = '0.8';\n\nvar getHTMLPaintForObject = function(o) {\n\treturn `<pre>${JSON.stringify(o, undefined, 4)}</pre>`;\n};\n\nconst currentElementContainers = {};\n\n// Keeps track of elements already painted so that respective container are updated\n// Mapping ensures multiple Perceptors\nconst createOrUpdateElementContainer = (id, context) => {\n\tif (!currentElementContainers[id]) {\n\t\tcurrentElementContainers[id] = document.createElement('div');\n\t\tmainContainer.appendChild(currentElementContainers[id]);\n\t}\n\tcurrentElementContainers[id].innerHTML = getHTMLPaintForObject(context);\n};\n\n/**\n * Logs SpectatorResult on DOM.\n * @param {Perceptor} perceptorInstance\n * @param {SpectatorResult} context\n */\nexport default (perceptorInstance, context) => {\n\treturn createOrUpdateElementContainer(perceptorInstance.element.id, context);\n};\n","/**\n * Logs SpectatorResult on console.\n * @param {Perceptor} perceptorInstance\n * @param {SpectatorResult} context\n */\nexport default function(perceptorInstance, context) {\n\tconsole.log(context); //eslint-disable-line\n}\n","import domSubscriber from './domSubscriber';\nimport consoleSubscriber from './consoleSubscriber';\n\n/**\n * Returns default subscriber\n * @param {string} subscriberName - Inbuilt subscriber name - 'dom', 'console' or 'None'\n *\n */\nconst getDefaultSubscriber = subscriberName => {\n\tif (subscriberName === 'dom') {\n\t\treturn domSubscriber;\n\t}\n\n\tif (subscriberName === 'console') {\n\t\treturn consoleSubscriber;\n\t}\n\n\treturn () => {}; //noop\n};\n\nexport default getDefaultSubscriber;\n","/**\n * Manager for Spectators\n */\nexport default class SpectatorManager {\n\tconstructor(chain) {\n\t\tthis.chain = chain || [];\n\t\tthis.prevResult = {};\n\t}\n\n\t/**\n\t * Adds a spectator to list\n\t * @param {function} fn - Function to be added to chain of spectators\n\t * @returns {number} - Spectator ID\n\t */\n\tuse(fn) {\n\t\tif (typeof fn === 'function') {\n\t\t\tthis.chain.push(fn);\n\t\t\treturn this.chain.length - 1;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Removes previously added Spectator\n\t * @param {number} id - spectator ID\n\t */\n\teject(id) {\n\t\tif (this.chain[id]) {\n\t\t\tthis.chain[id] = null;\n\t\t}\n\t}\n\n\t/**\n\t * Executes every spectator and combines their result\n\t * @param {Perceptor} PerceptorContext\n\t * @returns {object} - Merged results from all spectators\n\t */\n\trun(perceptorContext) {\n\t\tconst updatedResult = this.chain.reduce((currentResult, spectator) => {\n\t\t\tif (spectator) {\n\t\t\t\t// Combine result of previous Spectators with current spectator result\n\t\t\t\tcurrentResult = Object.assign(currentResult, spectator(perceptorContext, currentResult, this.prevResult) || {});\n\t\t\t}\n\t\t\treturn currentResult;\n\t\t}, Object.assign({}, this.prevResult));\n\t\tthis.prevResult = updatedResult;\n\t\treturn updatedResult;\n\t}\n}\n","/**\n * Manager for Spectators\n */\nexport default class SubscriberManager {\n\tconstructor(chain) {\n\t\tthis.chain = chain || [];\n\t}\n\n\t/**\n\t * Adds a subscriber to list\n\t * @param {function} fn - Function to be added to chain of subscribers\n\t * @returns {number} - Subscriber ID\n\t */\n\tuse(fn) {\n\t\tif (typeof fn === 'function') {\n\t\t\tthis.chain.push(fn);\n\t\t\treturn this.chain.length - 1;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Removes previously added subscriber\n\t * @param {number} id - Subscriber ID\n\t */\n\teject(id) {\n\t\tif (this.chain[id]) {\n\t\t\tthis.chain[id] = null;\n\t\t}\n\t}\n\n\t/**\n\t * Dispatcher to call all subscribers with payload\n\t * @param {Perceptor} PerceptorContext\n\t * @param {any} data - Additional payload for subscribers\n\t */\n\tdispatch(PerceptorContext, data) {\n\t\tthis.chain.every(subscribe => {\n\t\t\tif (subscribe) {\n\t\t\t\tsubscribe(PerceptorContext, data);\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t}\n}\n","// Refer : https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API\n// Shouldn't need a polyfill since it seems to be supported by major browsers\n// Refer caniuse for browser support: https://caniuse.com/#search=pagevisibility\n\n// Set the name of the hidden property and the change event for visibility\n// This is webkit specific\nlet hidden, visibilityChange;\nif (typeof document.hidden !== 'undefined') {\n\t// Opera 12.10 and Firefox 18 and later support\n\thidden = 'hidden';\n\tvisibilityChange = 'visibilitychange';\n} else if (typeof document.msHidden !== 'undefined') {\n\thidden = 'msHidden';\n\tvisibilityChange = 'msvisibilitychange';\n} else if (typeof document.webkitHidden !== 'undefined') {\n\thidden = 'webkitHidden';\n\tvisibilityChange = 'webkitvisibilitychange';\n}\n\nconst isPageVisible = () => {\n\treturn !document[hidden];\n};\n\n/**\n * Registers a function to be called on change of Page visibility\n * @param {function} fn - Function to be called on event\n * @param {boolean} attentionMode - Enable Attention mode\n */\nexport const onPageVisibilityChange = (fn = () => {}, attentionMode = true) => {\n\tlet lastVisibility = undefined;\n\n\t// When window is switched over and switched back - both pageVisibilty API event and 'focus' event are triggered.\n\t// The callback handler in each event ensure that callback(fn) will be called only if there is\n\t// actual change in visibility by checking previousState(lastVisibility).\n\t// The sequence of execution isn't guaranteed but sequential execution is guaranteed in `task` in event loop\n\n\tdocument.addEventListener(visibilityChange, () => {\n\t\tlet currentVisibility = isPageVisible();\n\t\tif (lastVisibility != currentVisibility) {\n\t\t\tfn(currentVisibility);\n\t\t\tlastVisibility = currentVisibility;\n\t\t}\n\t});\n\n\tif (attentionMode) {\n\t\twindow.addEventListener('blur', () => {\n\t\t\tif (lastVisibility != false) {\n\t\t\t\tfn(false);\n\t\t\t\tlastVisibility = false;\n\t\t\t}\n\t\t});\n\n\t\twindow.addEventListener('focus', () => {\n\t\t\tif (lastVisibility != true) {\n\t\t\t\tfn(true);\n\t\t\t\tlastVisibility = true;\n\t\t\t}\n\t\t});\n\t}\n};\n","/**\n * Interface for Schedulers\n */\n\nexport default class Scheduler {\n\tclearScheduler() {\n\t\tthrow new Error('Not implemented');\n\t}\n}\n","import { onPageVisibilityChange } from './visibilityHelper';\nimport SpectatorManager from '../spectators/spectatorManager';\nimport SubscriberManager from '../subscribers/subscriberManager';\nimport Scheduler from './Scheduler';\n\n/**\n * IntervalScheduler runs the spectator chain after every 'interval'\n */\nexport default class IntervalScheduler extends Scheduler {\n\tconstructor(options) {\n\t\tsuper();\n\t\tconst { config = { interval: 500, attentionMode: true }, spectatorChain, subscriberChain, context } = options;\n\t\tif (!(spectatorChain instanceof SpectatorManager && subscriberChain instanceof SubscriberManager)) {\n\t\t\tthrow new Error('Not a valid instance of spectatorChain/SubscriberChain');\n\t\t}\n\n\t\tthis._enabled = true;\n\n\t\tthis._schedule(config.interval, spectatorChain, subscriberChain, context);\n\n\t\t// Register for PageVisibility event changes\n\t\tonPageVisibilityChange(isPageVisible => {\n\t\t\tif (isPageVisible && this._enabled && !this.handleId) {\n\t\t\t\tthis._schedule(config.interval, spectatorChain, subscriberChain, context);\n\t\t\t} else if (this._enabled) {\n\t\t\t\tclearInterval(this.handleId);\n\t\t\t\tdelete this.handleId;\n\t\t\t}\n\t\t}, config.attentionMode);\n\t}\n\n\t/**\n\t * @private\n\t * Triggers the scheduler\n\t * @param {integer} interval  - time in ms\n\t * @param {SpectatorManager} spectatorChain - SpectatorManager to be invoked\n\t * @param {SubscriberManager} subscriberChain - SubscriberManager to be informed\n\t * @param {object} context  - Perceptor Context\n\t */\n\t_schedule(interval, spectatorChain, subscriberChain, context) {\n\t\tthis.handleId = setInterval(() => {\n\t\t\tconst spectatorsResult = spectatorChain.run(context);\n\t\t\treturn subscriberChain.dispatch(context, spectatorsResult);\n\t\t}, interval);\n\t}\n\n\t/**\n\t * Stops the current Scheduler\n\t */\n\tclearSchedule() {\n\t\tclearInterval(this.handleId);\n\t\tdelete this.handleId;\n\t\tthis._enabled = false;\n\n\t\treturn this;\n\t}\n}\n","import defaultConfig from './config/defaultConfig';\nimport { mergeConfig } from './config/helper';\nimport getDefaultSpectators from './spectators/defaultSpectators';\nimport getDefaultSubscriber from './subscribers/defaultSubscriber';\nimport SpectatorManager from './spectators/spectatorManager';\nimport SubscriberManager from './subscribers/subscriberManager';\nimport IntervalScheduler from './schedulers/intervalScheduler';\n\nclass Perceptor {\n\t/**\n\t * @constructor\n\t * @param {Element} DOMElement - HTMLElement to watch\n\t * @param {object} options - additional options\n\t * @returns {Perceptor}  - Instance of Perceptor\n\t */\n\tconstructor(DOMElement, options = {}) {\n\t\tif (!(DOMElement instanceof Element)) {\n\t\t\tthrow new Error('DOMElement is not a valid HTML Element');\n\t\t}\n\n\t\tthis.element = DOMElement;\n\t\tthis.config = mergeConfig(Object.assign({}, defaultConfig, Perceptor.defaults, { subscribers: [getDefaultSubscriber(options.defaultSubscriber || Perceptor.defaults.defaultSubscriber)], spectators: getDefaultSpectators() }), options);\n\t\tthis.spectatorChain = new SpectatorManager(this.config.spectators);\n\t\tthis.subscriberChain = new SubscriberManager(this.config.subscribers);\n\t\tthis.event = this.config.clickHandler ? this.config.clickHandler.bind(this, this) : () => {};\n\t}\n\n\t/**\n\t * Start to watch for visibility changes. Adds click event handler.\n\t * @return {Perceptor} - Current Instance\n\t */\n\twatch() {\n\t\tif (!this.scheduler) {\n\t\t\tthis.scheduler = new IntervalScheduler({ context: this, subscriberChain: this.subscriberChain, spectatorChain: this.spectatorChain, config: this.config.scheduler });\n\t\t\tthis.element.addEventListener('click', this.event, false);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop already started scheduler for visibility changes. Removes click event handler\n\t * @return {Perceptor} - Current Instance\n\t */\n\tunwatch() {\n\t\tif (this.scheduler) {\n\t\t\tthis.scheduler.clearSchedule();\n\t\t\tdelete this['scheduler'];\n\t\t\tthis.element.removeEventListener('click', this.event);\n\t\t}\n\n\t\treturn this;\n\t}\n}\n\n// Global Perceptor Configuration\n// This settings are applied to all Perceptor instance.\nPerceptor.defaults = Object.assign({}, defaultConfig);\n\nexport default Perceptor;\n"],"sourceRoot":""}